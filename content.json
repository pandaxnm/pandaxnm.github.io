{"meta":{"title":"小熊Blog","subtitle":"折腾不止","description":null,"author":"chaojie.xiong","url":"https://mokeee.com"},"pages":[{"title":"about","date":"2019-06-09T10:21:46.000Z","updated":"2019-06-09T10:21:46.637Z","comments":true,"path":"about/index.html","permalink":"https://mokeee.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"使用OpenSSL进行RSA签名和加密解密","slug":"open-ssl-rsa-sign-encrypt","date":"2019-07-09T03:56:32.000Z","updated":"2019-07-10T07:15:06.126Z","comments":true,"path":"2019/07/09/open-ssl-rsa-sign-encrypt/","link":"","permalink":"https://mokeee.com/2019/07/09/open-ssl-rsa-sign-encrypt/","excerpt":"PHP7之后，mcrypt扩展就已经被弃用，我们可以使用OpenSSL拓展来代替。 RSA加密算法是一种非对称加密算法，用法总结起来就是：公钥加密、私钥解密、私钥签名、公钥验签。","text":"PHP7之后，mcrypt扩展就已经被弃用，我们可以使用OpenSSL拓展来代替。 RSA加密算法是一种非对称加密算法，用法总结起来就是：公钥加密、私钥解密、私钥签名、公钥验签。 签名与加密的作用：1.签名是为了防止数据被篡改2.加密是为了防止数据被泄露 格式化公钥私钥1234567891011121314151617181920212223/** * 格式化私钥 * @param $privateKey * @return string */ private function getPrivateKey($privateKey) &#123; $key = chunk_split($privateKey,64,\"\\n\"); $key = \"-----BEGIN PRIVATE KEY-----\\n\" . $key . \"-----END PRIVATE KEY-----\\n\"; return $key; &#125; /** * 格式化公钥 * @param $privateKey * @return string */ private function getPublicKey($publicKey)&#123; $key = chunk_split($publicKey,64,\"\\n\"); $key = \"-----BEGIN PUBLIC KEY-----\\n\" . $key . \"-----END PUBLIC KEY-----\\n\"; return $key; &#125; 使用私钥签名12345678910111213/** * 签名 * @param $params * @param $privateKey * @return string */private function sign($data, $privateKey)&#123; $signature = ''; openssl_sign($str, $signature, $privateKey, OPENSSL_ALGO_SHA1); return base64_encode($signature);&#125; 使用公钥验签1234567891011121314151617/** * 验签 * @param $return * @param $sign * @param $publicKey * @return bool */public function verify($params, $sign, $publicKey)&#123; $verify = openssl_verify($params, base64_decode($sign), $publicKey); if ($verify != 1) &#123; return false; &#125; return true;&#125; 使用公钥加密1234567891011121314/** * rsa 公钥加密 * @param $data string 待加密的数据 * @param string $public_key 公钥 * @return string */public function rsaPublicEncrypt($data, $publicKey)&#123; $key = openssl_pkey_get_public($publicKey); $encrypted = ''; openssl_public_encrypt($data, $encrypted, $key); return base64_encode($encrypted);&#125; 使用私钥解密1234567891011/** * 私钥解密 * @param $encrypted 被加密的数据 * @param $private_key 私钥 * @return string */public function rsaPrivateDecrypt($encrypted, $private_key)&#123; openssl_private_decrypt(base64_decode($encrypted),$decrypted,$private_key); return $decrypted;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://mokeee.com/categories/PHP/"}],"tags":[{"name":"openSSL","slug":"openSSL","permalink":"https://mokeee.com/tags/openSSL/"},{"name":"RSA","slug":"RSA","permalink":"https://mokeee.com/tags/RSA/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://mokeee.com/categories/PHP/"}]},{"title":"Mac上使用Homebrew安装go","slug":"go-start","date":"2019-06-22T15:46:47.000Z","updated":"2019-06-22T16:08:14.802Z","comments":true,"path":"2019/06/22/go-start/","link":"","permalink":"https://mokeee.com/2019/06/22/go-start/","excerpt":"","text":"最近准备学go，首先当然是安装开发环境了，贴一下安装过程。😬 我的电脑是Mac，使用Homebrew来安装go。 安装go使用Homebrew安装go 1brew install go 安装完成，检查一下 1go version","categories":[{"name":"go","slug":"go","permalink":"https://mokeee.com/categories/go/"}],"tags":[],"keywords":[{"name":"go","slug":"go","permalink":"https://mokeee.com/categories/go/"}]},{"title":"Mac上使用Homebrew搭建LNMP环境（简要版）","slug":"mac-homebrew-lnmp","date":"2019-06-09T09:18:39.000Z","updated":"2019-06-09T14:19:23.084Z","comments":true,"path":"2019/06/09/mac-homebrew-lnmp/","link":"","permalink":"https://mokeee.com/2019/06/09/mac-homebrew-lnmp/","excerpt":"最近发现自己这台Mac充电口已经糊掉了，并且使用的时候发热严重，于是向公司申请了一台。","text":"最近发现自己这台Mac充电口已经糊掉了，并且使用的时候发热严重，于是向公司申请了一台。 结果给了我一台13寸的，而且键盘磨得漆都掉了。🤣 拿到手第一件事情就是咔咔重装系统，然后开始装开发环境。 一、安装Homebrew1.安装comman line Homebrew 是一个包管理器，用于在Mac上安装一些OS X没有的UNIX工具 1xcode-select --install 如果提示失败，请尝试手动安装到这个地址 https://developer.apple.com/download/more/ 下载Command Line Tools，选择适合自己的版本。 2.安装Homebrew运行下面的命令即可安装Homebrew，安装开始前会有提示，同意即可。 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 二、安装Nginx运行下面的命令来安装 1brew install nginx 安装完成后将Nginx加入开机自启 12cp /usr/local/opt/nginx/homebrew.mxcl.nginx.plist ~/Library/LaunchAgents/launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist 给Nginx root权限 (路径根据版本而定) 12sudo chown root:wheel /usr/local/Cellar/nginx/1.6.0_1/bin/nginxsudo chmod u+s /usr/local/Cellar/nginx/1.6.0_1/bin/nginx 如果nginx启动报错：nginx: [error] open() &quot;/usr/local/var/run/nginx.pid&quot; failed (2: No such file or directory) 执行 1sudo nginx -c /usr/local/etc/nginx/nginx.conf 三、安装MySql1brew install mysql@5.7 安装完成后开启mysql： 1/usr/local/opt/mysql@5.7/bin/mysql.server start 然后设置密码： 1/usr/local/opt/mysql@5.7/bin/mysql_secure_installation 根据提示操作即可 将MySql加入开机自启（路径根据版本而定） 12cp /usr/local/opt/mysql@5.7/homebrew.mxcl.mysql@5.7.plist ~/Library/LaunchAgents/launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql@5.7.plist 四、安装PHP1.安装PHP1brew install php@7.1 将php加入环境变量，运行： 12echo 'export PATH=\"/usr/local/opt/php@7.1/bin:$PATH\"' &gt;&gt; ~/.bash_profileecho 'export PATH=\"/usr/local/opt/php@7.1/sbin:$PATH\"' &gt;&gt; ~/.bash_profile 关闭终端，重新打开 2.安装PHP扩展我们可以使用pecl命令来安装PHP拓展，如果你安装的PHP版本&gt;=7.1，pecl也一同安装好了。 使用pecl安装拓展，只需执行命令即可，其他的会给你自动配置好，是不是敲方便的！ 安装Yaf扩展：pecl install yaf安装redis扩展： pecl install install安装debug：pecl install xdebug 扩展安装完成后记得重启php-fpm 1brew services restart php@7.1 五、安装redis同理，运行 1brew install redis 六、命令可能会用到的一些命令： 1. 搜索1brew search php 2.安装卸载1brew install\\uninstall php@7.1 3.启动\\重启\\停止服务：1brew services start\\restart\\stop nginx\\mysql@5.7\\php@7.1 4.查看某个包的信息：1brew info nginx 该命令会显示安装路径、配置文件等信息","categories":[],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"https://mokeee.com/tags/Homebrew/"},{"name":"LNMP","slug":"LNMP","permalink":"https://mokeee.com/tags/LNMP/"}],"keywords":[]},{"title":"记一次使用PHP将word转为excel的经历","slug":"word-to-excel-use-php","date":"2019-01-12T08:24:06.000Z","updated":"2019-06-09T09:18:02.850Z","comments":true,"path":"2019/01/12/word-to-excel-use-php/","link":"","permalink":"https://mokeee.com/2019/01/12/word-to-excel-use-php/","excerpt":"昨天一位朋友找到我，说他手上有几千个word表格需要转换到一个excel文件里，他在网上也没有找到满足需求的软件，于是让我帮忙用程序实现。","text":"昨天一位朋友找到我，说他手上有几千个word表格需要转换到一个excel文件里，他在网上也没有找到满足需求的软件，于是让我帮忙用程序实现。 需求需求如下图所示：每个文档文档中有一个或多个格式固定的表格，需要把每一个word表格转换为excel文件里的一行。 from: to: 寻找解决方案我首先想到的是用PHP读取word文档，处理之后转成excel。 转成excel比较简单，使用PHP系统函数fputcsv就可以搞定，现在需要做的是读取到word文档里的内容。 紧接着我便去网上查找，看有没有PHP的扩展能够读取word文档。在Github搜索到一个叫做 PHPWord 的扩展，不过遗憾的是，这个扩展只能往word文档里写入内容，并不能读取。 我又想，能不能把word转成其他格式再读取。于是我将word文档的后缀改成了txt,打开文件后内容如下图。 密密麻麻的一大堆，反正我是没能从中找到什么规律，于是放弃了这种方法。 接着我在word的另存为功能中，发现可以另存为其他格式。 于是选择保存为htm文件，随后在浏览器中打开转换好的文件，发现表格转换成了html中的table表格，非常标准。 这样我只需要遍历读取htm文件，获取其中的内容，再进行相应处理便能得到最终数据。 进行处理准备 首先我在网上下载了软件，将word文档批量转换为htm文件，并放在同一目录下 读取文件内容我们事先将所有转换好的文件放在了同一目录下，所以只需要遍历该目录，并使用file_get_contents()函数就能获取到每个文件的内容。 提取有用内容查看htm源代码能发现，每个word表格转换后变成了一个html表格，只需要先取到&lt;table&gt;&lt;/table&gt;标签里的内容，然后再按行分割，按列分割，便能得到我们想要的数据了。 附上简略代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//生成csv文件function writeExcel()&#123; //写入文档头部 $fileName = './data.csv'; file_put_contents($fileName,''); $handle = fopen($fileName, 'w'); fwrite($handle, chr(0xEF).chr(0xBB).chr(0xBF)); // 写入BOM头，防止乱码 $titleArr = ['A' =&gt; '样品类型', 'B' =&gt; '图幅编号'];//次数省略 fputcsv($handle, $titleArr); return $handle;&#125;//读取文件夹下的所有文件function scanFile($path)&#123; $result = []; $files = scandir($path); foreach ($files as $file) &#123; if ($file != '.' &amp;&amp; $file != '..') &#123; $result[] = basename($file); &#125; &#125; return $result;&#125;//提取表格内容function getContents()&#123; $filesArr = scanFile('./'); $handle = writeExcelHeader(); foreach ($filesName as $k =&gt; $v)&#123; //读取文件内容 $text = file_get_contents($path . $v); //转换编码 $text = iconv(\"gb2312\", \"utf-8//IGNORE\",$text); //去除html标签多余属性 $text = preg_replace(\"/&lt;([a-zA-Z]+)[^&gt;]*&gt;/\",\"&lt;\\\\1&gt;\",$text); //提取表格内容 preg_match_all(\"/&lt;table&gt;(.*?)&lt;\\/table&gt;/is\",$text,$matches); //处理表格内容 foreach ($matches[1] as $match)&#123; html2excel($match, $handle); &#125;&#125;//处理表格内容function convert($content)&#123; $res = []; //按行拆分 $trArr = explode('&lt;tr&gt;', $content); foreach ($trArr as $k =&gt; $tr)&#123; //去除多余标签 $tr = str_replace('&lt;/tr&gt;','', $tr); //按列拆分 $tdArr = explode('&lt;td&gt;', $tr); foreach ($tdArr as $kk =&gt; $td)&#123; //去除多余标签 $td = str_replace('&lt;/td&gt;','', $td); //去除html标签 得到内容 $text = strip_tags($td); $res[] = $text; &#125; &#125; fputcsv($handel, $res);&#125;getContents(); 最后使用到的一些函数： iconv() 编码转换 preg_replace() 使用正则替换文本 preg_match_all() 使用正则获取内容 strip_tags() 去除文本中的html标签 str_replace() 文本替换 fputcsv() 将制定内容写入csv文件","categories":[{"name":"PHP","slug":"PHP","permalink":"https://mokeee.com/categories/PHP/"}],"tags":[{"name":"Safari","slug":"Safari","permalink":"https://mokeee.com/tags/Safari/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://mokeee.com/categories/PHP/"}]},{"title":"Safari【阻止跨网站追踪】遇到的问题","slug":"safari-cookie","date":"2019-01-06T07:30:59.000Z","updated":"2019-06-09T09:17:04.172Z","comments":true,"path":"2019/01/06/safari-cookie/","link":"","permalink":"https://mokeee.com/2019/01/06/safari-cookie/","excerpt":"","text":"需求描述现有AB两个域名，分别使用在AB网站上。 A向B发送一个jsonp跨域请求，进行用户登录操作 B收到请求并验证通过后会在自己的域名下写一个包含当前用户信息的cookie 当A网站再次向B网站发起获取用户信息的请求时，B网站会读取自己域名下的这个cookie来获取当前用户的信息并返回给A 遇到的问题在Windows PC上测试时一切正常，没有任何问题。当使用Safari浏览器访问A网站时，用户登录操作正常，但在登录成功后，向B网站发起获取用户信息的请求时，总是提示获取不到。 在一番查找资料后发现，iOS系统上的Safari设置中默认开启了 阻止跨网站追踪 的功能，从而导致A网站向B网站发请求，B网站写cookie在B域名下的操作也无法完成… **这个问题会出现在所有使用AppleWebkit内核的浏览器中。 由于iOS系统限制，苹果只允许第三方浏览器使用AppleWebkit内核，所以按理iOS上的所有浏览器都会出现这个问题。 解决办法严格来说也不算解决办法，算曲线救国吧… 当A向B发起登录请求并收到返回的数据后，A网站前端将B返回的数据存在A的cookie中，并在以后每次请求B时将cookie中的信息以参数形式发送给B。","categories":[],"tags":[],"keywords":[]}]}