{"meta":{"title":"小熊Blog","subtitle":null,"description":null,"author":"chaojie.xiong","url":"http://mokeee.com"},"pages":[],"posts":[{"title":"记一次使用PHP将word转为excel的经历","slug":"word-to-excel-use-php","date":"2019-01-12T08:24:06.000Z","updated":"2019-06-09T08:56:34.896Z","comments":true,"path":"2019/01/12/word-to-excel-use-php/","link":"","permalink":"http://mokeee.com/2019/01/12/word-to-excel-use-php/","excerpt":"","text":"昨天一位朋友找到我，说他手上有几千个word表格需要转换到一个excel文件里，他在网上也没有找到满足需求的软件，于是让我帮忙用程序实现。 需求需求如下图所示：每个文档文档中有一个或多个格式固定的表格，需要把每一个word表格转换为excel文件里的一行。 from: to: 寻找解决方案我首先想到的是用PHP读取word文档，处理之后转成excel。 转成excel比较简单，使用PHP系统函数fputcsv就可以搞定，现在需要做的是读取到word文档里的内容。 紧接着我便去网上查找，看有没有PHP的扩展能够读取word文档。在Github搜索到一个叫做 PHPWord 的扩展，不过遗憾的是，这个扩展只能往word文档里写入内容，并不能读取。 我又想，能不能把word转成其他格式再读取。于是我将word文档的后缀改成了txt,打开文件后内容如下图。 密密麻麻的一大堆，反正我是没能从中找到什么规律，于是放弃了这种方法。 接着我在word的另存为功能中，发现可以另存为其他格式。 于是选择保存为htm文件，随后在浏览器中打开转换好的文件，发现表格转换成了html中的table表格，非常标准。 这样我只需要遍历读取htm文件，获取其中的内容，再进行相应处理便能得到最终数据。 进行处理准备 首先我在网上下载了软件，将word文档批量转换为htm文件，并放在同一目录下 读取文件内容我们事先将所有转换好的文件放在了同一目录下，所以只需要遍历该目录，并使用file_get_contents()函数就能获取到每个文件的内容。 提取有用内容查看htm源代码能发现，每个word表格转换后变成了一个html表格，只需要先取到&lt;table&gt;&lt;/table&gt;标签里的内容，然后再按行分割，按列分割，便能得到我们想要的数据了。 附上简略代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//生成csv文件function writeExcel()&#123; //写入文档头部 $fileName = './data.csv'; file_put_contents($fileName,''); $handle = fopen($fileName, 'w'); fwrite($handle, chr(0xEF).chr(0xBB).chr(0xBF)); // 写入BOM头，防止乱码 $titleArr = ['A' =&gt; '样品类型', 'B' =&gt; '图幅编号'];//次数省略 fputcsv($handle, $titleArr); return $handle;&#125;//读取文件夹下的所有文件function scanFile($path)&#123; $result = []; $files = scandir($path); foreach ($files as $file) &#123; if ($file != '.' &amp;&amp; $file != '..') &#123; $result[] = basename($file); &#125; &#125; return $result;&#125;//提取表格内容function getContents()&#123; $filesArr = scanFile('./'); $handle = writeExcelHeader(); foreach ($filesName as $k =&gt; $v)&#123; //读取文件内容 $text = file_get_contents($path . $v); //转换编码 $text = iconv(\"gb2312\", \"utf-8//IGNORE\",$text); //去除html标签多余属性 $text = preg_replace(\"/&lt;([a-zA-Z]+)[^&gt;]*&gt;/\",\"&lt;\\\\1&gt;\",$text); //提取表格内容 preg_match_all(\"/&lt;table&gt;(.*?)&lt;\\/table&gt;/is\",$text,$matches); //处理表格内容 foreach ($matches[1] as $match)&#123; html2excel($match, $handle); &#125;&#125;//处理表格内容function convert($content)&#123; $res = []; //按行拆分 $trArr = explode('&lt;tr&gt;', $content); foreach ($trArr as $k =&gt; $tr)&#123; //去除多余标签 $tr = str_replace('&lt;/tr&gt;','', $tr); //按列拆分 $tdArr = explode('&lt;td&gt;', $tr); foreach ($tdArr as $kk =&gt; $td)&#123; //去除多余标签 $td = str_replace('&lt;/td&gt;','', $td); //去除html标签 得到内容 $text = strip_tags($td); $res[] = $text; &#125; &#125; fputcsv($handel, $res);&#125;getContents(); 最后使用到的一些函数： iconv() 编码转换 preg_replace() 使用正则替换文本 preg_match_all() 使用正则获取内容 strip_tags() 去除文本中的html标签 str_replace() 文本替换 fputcsv() 将制定内容写入csv文件","categories":[{"name":"PHP","slug":"PHP","permalink":"http://mokeee.com/categories/PHP/"}],"tags":[],"keywords":[{"name":"PHP","slug":"PHP","permalink":"http://mokeee.com/categories/PHP/"}]},{"title":"Safari【阻止跨网站追踪】遇到的问题","slug":"safari-cookie","date":"2019-01-06T07:30:59.000Z","updated":"2019-06-09T09:04:05.641Z","comments":true,"path":"2019/01/06/safari-cookie/","link":"","permalink":"http://mokeee.com/2019/01/06/safari-cookie/","excerpt":"","text":"需求描述现有AB两个域名，分别使用在AB网站上。 A向B发送一个jsonp跨域请求，进行用户登录操作 B收到请求并验证通过后会在自己的域名下写一个包含当前用户信息的cookie 当A网站再次向B网站发起获取用户信息的请求时，B网站会读取自己域名下的这个cookie来获取当前用户的信息并返回给A 遇到的问题在Windows PC上测试时一切正常，没有任何问题。当使用Safari浏览器访问A网站时，用户登录操作正常，但在登录成功后，向B网站发起获取用户信息的请求时，总是提示获取不到。 在一番查找资料后发现，iOS系统上的Safari设置中默认开启了 阻止跨网站追踪 的功能，从而导致A网站向B网站发请求，B网站写cookie在B域名下的操作也无法完成… **这个问题会出现在所有使用AppleWebkit内核的浏览器中。 由于iOS系统限制，苹果只允许第三方浏览器使用AppleWebkit内核，所以按理iOS上的所有浏览器都会出现这个问题。 解决办法严格来说也不算解决办法，算曲线救国吧… 当A向B发起登录请求并收到返回的数据后，A网站前端将B返回的数据存在A的cookie中，并在以后每次请求B时将cookie中的信息以参数形式发送给B。","categories":[],"tags":[],"keywords":[]}]}