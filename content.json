{"pages":[{"title":"关于我","text":"因为很菜，所以不断学习中…","link":"/about/index.html"}],"posts":[{"title":"简单的接口加密","text":"在前后端的数据传输中，为了保证数据安全等原因，我们需要对传输的数据进行加密。 流程客户端发送请求前加密，服务端接收到数据后解密服务端返回数据前加密，客户端接收到数据后解密 加密方式加密方式采用 aes-128-cbc客户端和服务端的key和iv要保持一致 实现客户端以VUE为例 创建一个名为 encrypt.js 的文件，用于对数据加密解密 记得先安装扩展 1yarn add crypto-js 12345678910111213141516171819202122import CryptoJS from 'crypto-js/crypto-js'const key = CryptoJS.enc.Utf8.parse(\"1234123412ABCDEF\");const iv = CryptoJS.enc.Utf8.parse('ABCDEF1234123412');//解密export function Decrypt(data) { let decryptedData = CryptoJS.AES.decrypt(data, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); let decryptedStr = decryptedData.toString(CryptoJS.enc.Utf8); return decryptedStr.toString();}//加密export function Encrypt(data) { let string = CryptoJS.enc.Utf8.parse(JSON.stringify(data)); let encrypted = CryptoJS.AES.encrypt(string, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return encrypted.toString();} 创建HTTP请求文件 http.js 这里我们使用axios+qs，同样，记得安装扩展 12yarn add axiosyarn add qs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import { Encrypt, Decrypt } from './aes';import axios from '@/js_sdk/gangdiedao-uni-axios'import qs from 'qs';const service = axios.create({ baseURL: '/api', // withCredentials: true, timeout: 10000});//发送请求前对数据加密service.interceptors.request.use( config =&gt; { if(config.method === 'post'){ let encrypt = {encryptedData: Encrypt(config.data)}; config.data = qs.stringify(encrypt) }else{ let encrypt = {encryptedData:Encrypt(config.params)}; config.params = encrypt; } return config });//收到响应后解密数据service.interceptors.response.use( response =&gt; { const res = JSON.parse(Decrypt(response.data)); return res }, error =&gt; { return Promise.reject(error) });export function get(url, data = {},) { return new Promise((resolve,reject) =&gt; { service.get(url, { params: data, }) .then((response) =&gt; { return response; }) .then(response =&gt; { resolve(response); },err =&gt; { reject(err) }) })}export function post(url,data = {}){ return new Promise((resolve,reject) =&gt; { service.post(url, data) .then((response) =&gt; { return response; }) .then(response =&gt; { resolve(response); },err =&gt; { reject(err) }) })} 这样，客户端发送的请求是这个样子： https://example.com/api/user?encryptedData=LJGKLSDA34FJSLKDFJF 服务端 定义加密解密方法 1234567891011121314151617181920212223const KEY = '1234123412ABCDEF';const IV = 'ABCDEF1234123412';/** * 解密 * @param $data * @return mixed */public function decrypt($data) { $cryptText = base64_decode($data); $decrypted = trim(openssl_decrypt($cryptText, 'aes-128-cbc', self::KEY, OPENSSL_RAW_DATA,self::IV)); return json_decode($decrypted, true);}/** * 加密 * @param $data * @return string */public function encrypt($data) { $cryptText = openssl_encrypt($data,\"aes-128-cbc\",self::KEY,OPENSSL_RAW_DATA,self::IV); return base64_encode($cryptText);} 使用 解密 12345678910$request = Yii::$app-&gt;getRequest();if($method == 'post'){ $encryptedData = $request-&gt;post('encryptedData');}else{ $encryptedData = $request-&gt;get('encryptedData');}if (!$encryptedData) { return [];}$decrypted = $this-&gt;decrypt($encryptedData); 加密 12345$data = [ 'name' =&gt; 'panda', 'age' =&gt; 18,]$encrypted = $this-&gt;encrypt(json_encode($data));","link":"/2020/01/05/api-simple-encrypt/"},{"title":"Mac上使用Homebrew搭建LNMP环境（简要版）","text":"最近发现自己这台Mac充电口已经糊掉了，并且使用的时候发热严重，于是向公司申请了一台。 结果给了我一台13寸的，而且键盘磨得漆都掉了。🤣 拿到手第一件事情就是咔咔重装系统，然后开始装开发环境。 一、安装Homebrew1.安装comman line Homebrew 是一个包管理器，用于在Mac上安装一些OS X没有的UNIX工具 1xcode-select --install 如果提示失败，请尝试手动安装到这个地址 https://developer.apple.com/download/more/ 下载Command Line Tools，选择适合自己的版本。 2.安装Homebrew运行下面的命令即可安装Homebrew，安装开始前会有提示，同意即可。 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 二、安装Nginx运行下面的命令来安装 1brew install nginx 安装完成后将Nginx加入开机自启 12cp /usr/local/opt/nginx/homebrew.mxcl.nginx.plist ~/Library/LaunchAgents/launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist 给Nginx root权限 (路径根据版本而定) 12sudo chown root:wheel /usr/local/Cellar/nginx/1.6.0_1/bin/nginxsudo chmod u+s /usr/local/Cellar/nginx/1.6.0_1/bin/nginx 如果nginx启动报错：nginx: [error] open() &quot;/usr/local/var/run/nginx.pid&quot; failed (2: No such file or directory) 执行 1sudo nginx -c /usr/local/etc/nginx/nginx.conf 三、安装MySql1brew install mysql@5.7 安装完成后开启mysql： 1/usr/local/opt/mysql@5.7/bin/mysql.server start 然后设置密码： 1/usr/local/opt/mysql@5.7/bin/mysql_secure_installation 根据提示操作即可 将MySql加入开机自启（路径根据版本而定） 12cp /usr/local/opt/mysql@5.7/homebrew.mxcl.mysql@5.7.plist ~/Library/LaunchAgents/launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql@5.7.plist 四、安装PHP1.安装PHP1brew install php@7.1 将php加入环境变量，运行： 12echo 'export PATH=\"/usr/local/opt/php@7.1/bin:$PATH\"' &gt;&gt; ~/.bash_profileecho 'export PATH=\"/usr/local/opt/php@7.1/sbin:$PATH\"' &gt;&gt; ~/.bash_profile 关闭终端，重新打开 2.安装PHP扩展我们可以使用pecl命令来安装PHP拓展，如果你安装的PHP版本&gt;=7.1，pecl也一同安装好了。 使用pecl安装拓展，只需执行命令即可，其他的会给你自动配置好，是不是敲方便的！ 安装Yaf扩展：pecl install yaf安装redis扩展： pecl install install安装debug：pecl install xdebug 扩展安装完成后记得重启php-fpm 1brew services restart php@7.1 五、安装redis同理，运行 1brew install redis 六、命令可能会用到的一些命令： 1. 搜索1brew search php 2.安装卸载1brew install\\uninstall php@7.1 3.启动\\重启\\停止服务：1brew services start\\restart\\stop nginx\\mysql@5.7\\php@7.1 4.查看某个包的信息：1brew info nginx 该命令会显示安装路径、配置文件等信息","link":"/2019/06/09/mac-homebrew-lnmp/"},{"title":"使用OpenSSL进行RSA签名和加密解密","text":"PHP7之后，mcrypt扩展就已经被弃用，我们可以使用OpenSSL拓展来代替。 RSA加密算法是一种非对称加密算法，用法总结起来就是：公钥加密、私钥解密、私钥签名、公钥验签。 签名与加密的作用：1.签名是为了防止数据被篡改2.加密是为了防止数据被泄露 格式化公钥私钥1234567891011121314151617181920212223/** * 格式化私钥 * @param $privateKey * @return string */ private function getPrivateKey($privateKey) { $key = chunk_split($privateKey,64,\"\\n\"); $key = \"-----BEGIN PRIVATE KEY-----\\n\" . $key . \"-----END PRIVATE KEY-----\\n\"; return $key; } /** * 格式化公钥 * @param $privateKey * @return string */ private function getPublicKey($publicKey){ $key = chunk_split($publicKey,64,\"\\n\"); $key = \"-----BEGIN PUBLIC KEY-----\\n\" . $key . \"-----END PUBLIC KEY-----\\n\"; return $key; } 使用私钥签名12345678910111213/** * 签名 * @param $params * @param $privateKey * @return string */private function sign($data, $privateKey){ $signature = ''; openssl_sign($str, $signature, $privateKey, OPENSSL_ALGO_SHA1); return base64_encode($signature);} 使用公钥验签1234567891011121314151617/** * 验签 * @param $return * @param $sign * @param $publicKey * @return bool */public function verify($params, $sign, $publicKey){ $verify = openssl_verify($params, base64_decode($sign), $publicKey); if ($verify != 1) { return false; } return true;} 使用公钥加密1234567891011121314/** * rsa 公钥加密 * @param $data string 待加密的数据 * @param string $public_key 公钥 * @return string */public function rsaPublicEncrypt($data, $publicKey){ $key = openssl_pkey_get_public($publicKey); $encrypted = ''; openssl_public_encrypt($data, $encrypted, $key); return base64_encode($encrypted);} 使用私钥解密1234567891011/** * 私钥解密 * @param $encrypted 被加密的数据 * @param $private_key 私钥 * @return string */public function rsaPrivateDecrypt($encrypted, $private_key){ openssl_private_decrypt(base64_decode($encrypted),$decrypted,$private_key); return $decrypted;}","link":"/2019/07/09/open-ssl-rsa-sign-encrypt/"},{"title":"使用Redis锁来处理并发","text":"Redis 问题： 最近在和第三方对接支付，今天看日志发现他们的回调竟然并发了，有点方。虽然每次回调的时候，都会查数据库检查这个订单的状态，然后对进行相应处理。但同一个订单如果遇到并发，第一个请求还没写入数据库，第二个请求就来了，这种情况就会导致错误。 解决办法： 使用Redis锁，每个请求到达时先加锁，如果加锁成功才会执行后面的业务逻辑，执行结束后释放锁。 比如：同一个订单并发的情况，我们可以使用订单号作为Redis的键名，每次请求前都会先加锁，如果加锁失败，说明该订单正在进行处理，并把这个请求挡回去；如果加锁成功，则执行后面的业务逻辑，并在完成后解锁。 我想到的是使用Redis的set命令，2.6.12之后版本，Redis set指令支持了nx、ex模式，并支持原子化地设置过期时间。 NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。 PHP实现 加锁12345678910111213141516171819/** * 加锁 * @param string $orderId 订单ID * @return bool|int 加锁成功返回唯一锁ID，加锁失败返回false */public static function addLock($orderId){ if(!$orderId){ return false; } $key = self::REDIS_LOCK_NAME . $orderId; $client = BaseRedis::getClient(); //生成锁ID 自行实现 $lockId = uniqid(); //需要设置一个到期时间，避免死锁 $res = $client-&gt;set($key, $lockId, ['nx', 'ex' =&gt; self::REDIS_LOCK_EXPIRE_TIME]); return $res ? $lockId : $res;} 2.解锁 解锁时用lockId进行比较，如果相等则删除锁。 watch: 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 1234567891011121314151617181920212223/** * 解锁 * @param string $orderId 订单ID * @param string $lockId 锁唯一ID * @return bool */public static function unLock($orderId, $lockId){ if(!$orderId){ return false; } $key = self::REDIS_LOCK_NAME . $orderId; $client = BaseRedis::getClient(); $client-&gt;watch($key); if ($lockId == $client-&gt;get($key)) { // 以 MULTI 开始一个事务，然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务，一并执行事务中的所有命令 $client-&gt;multi()-&gt;del($key)-&gt;exec(); return true; } $client-&gt;unwatch(); return false;} 目前对分布式缓存还不太了解，后续学习。","link":"/2019/07/10/redis-lock/"},{"title":"Safari【阻止跨网站追踪】遇到的问题","text":"Safari Cookie 需求描述现有AB两个域名，分别使用在AB网站上。 A向B发送一个jsonp跨域请求，进行用户登录操作 B收到请求并验证通过后会在自己的域名下写一个包含当前用户信息的cookie 当A网站再次向B网站发起获取用户信息的请求时，B网站会读取自己域名下的这个cookie来获取当前用户的信息并返回给A 遇到的问题在Windows PC上测试时一切正常，没有任何问题。当使用Safari浏览器访问A网站时，用户登录操作正常，但在登录成功后，向B网站发起获取用户信息的请求时，总是提示获取不到。 在一番查找资料后发现，iOS系统上的Safari设置中默认开启了 阻止跨网站追踪 的功能，从而导致A网站向B网站发请求，B网站写cookie在B域名下的操作也无法完成… **这个问题会出现在所有使用AppleWebkit内核的浏览器中。 由于iOS系统限制，苹果只允许第三方浏览器使用AppleWebkit内核，所以按理iOS上的所有浏览器都会出现这个问题。 解决办法严格来说也不算解决办法，算曲线救国吧… 当A向B发起登录请求并收到返回的数据后，A网站前端将B返回的数据存在A的cookie中，并在以后每次请求B时将cookie中的信息以参数形式发送给B。","link":"/2019/01/06/safari-cookie/"},{"title":"记一次使用PHP将word转为excel的经历","text":"昨天一位朋友找到我，说他手上有几千个word表格需要转换到一个excel文件里，他在网上也没有找到满足需求的软件，于是让我帮忙用程序实现。 需求需求如下图所示：每个文档文档中有一个或多个格式固定的表格，需要把每一个word表格转换为excel文件里的一行。 from: to: 寻找解决方案我首先想到的是用PHP读取word文档，处理之后转成excel。 转成excel比较简单，使用PHP系统函数fputcsv就可以搞定，现在需要做的是读取到word文档里的内容。 紧接着我便去网上查找，看有没有PHP的扩展能够读取word文档。在Github搜索到一个叫做 PHPWord 的扩展，不过遗憾的是，这个扩展只能往word文档里写入内容，并不能读取。 我又想，能不能把word转成其他格式再读取。于是我将word文档的后缀改成了txt,打开文件后内容如下图。 密密麻麻的一大堆，反正我是没能从中找到什么规律，于是放弃了这种方法。 接着我在word的另存为功能中，发现可以另存为其他格式。 于是选择保存为htm文件，随后在浏览器中打开转换好的文件，发现表格转换成了html中的table表格，非常标准。 这样我只需要遍历读取htm文件，获取其中的内容，再进行相应处理便能得到最终数据。 进行处理准备 首先我在网上下载了软件，将word文档批量转换为htm文件，并放在同一目录下 读取文件内容我们事先将所有转换好的文件放在了同一目录下，所以只需要遍历该目录，并使用file_get_contents()函数就能获取到每个文件的内容。 提取有用内容查看htm源代码能发现，每个word表格转换后变成了一个html表格，只需要先取到&lt;table&gt;&lt;/table&gt;标签里的内容，然后再按行分割，按列分割，便能得到我们想要的数据了。 附上简略代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//生成csv文件function writeExcel(){ //写入文档头部 $fileName = './data.csv'; file_put_contents($fileName,''); $handle = fopen($fileName, 'w'); fwrite($handle, chr(0xEF).chr(0xBB).chr(0xBF)); // 写入BOM头，防止乱码 $titleArr = ['A' =&gt; '样品类型', 'B' =&gt; '图幅编号'];//次数省略 fputcsv($handle, $titleArr); return $handle;}//读取文件夹下的所有文件function scanFile($path){ $result = []; $files = scandir($path); foreach ($files as $file) { if ($file != '.' &amp;&amp; $file != '..') { $result[] = basename($file); } } return $result;}//提取表格内容function getContents(){ $filesArr = scanFile('./'); $handle = writeExcelHeader(); foreach ($filesName as $k =&gt; $v){ //读取文件内容 $text = file_get_contents($path . $v); //转换编码 $text = iconv(\"gb2312\", \"utf-8//IGNORE\",$text); //去除html标签多余属性 $text = preg_replace(\"/&lt;([a-zA-Z]+)[^&gt;]*&gt;/\",\"&lt;\\\\1&gt;\",$text); //提取表格内容 preg_match_all(\"/&lt;table&gt;(.*?)&lt;\\/table&gt;/is\",$text,$matches); //处理表格内容 foreach ($matches[1] as $match){ html2excel($match, $handle); }}//处理表格内容function convert($content){ $res = []; //按行拆分 $trArr = explode('&lt;tr&gt;', $content); foreach ($trArr as $k =&gt; $tr){ //去除多余标签 $tr = str_replace('&lt;/tr&gt;','', $tr); //按列拆分 $tdArr = explode('&lt;td&gt;', $tr); foreach ($tdArr as $kk =&gt; $td){ //去除多余标签 $td = str_replace('&lt;/td&gt;','', $td); //去除html标签 得到内容 $text = strip_tags($td); $res[] = $text; } } fputcsv($handel, $res);}getContents(); 最后使用到的一些函数： iconv() 编码转换 preg_replace() 使用正则替换文本 preg_match_all() 使用正则获取内容 strip_tags() 去除文本中的html标签 str_replace() 文本替换 fputcsv() 将制定内容写入csv文件","link":"/2019/01/12/word-to-excel-use-php/"},{"title":"MongoDB使用","text":"MongoDB 简介 基于分布式文件存储的数据库。由C++语言编写。 介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 数据形式MongoDB 存储的数据对象由键值对组成。MongoDB 所有存储在集合中的数据都是 BSON 格式。BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称。 形式如下： 1234567891011121314151617{ \"_id\" : ObjectId(\"5c89f787ca6e4e3ac1ecabkk\"), \"update_time\" : ISODate(\"2019-06-03T15:00:42.142Z\"), \"create_time\" : ISODate(\"2019-03-14T14:41:11.217Z\"), \"creator\" : \"test_user\", \"admin\" : [ \"admin1\", \"admin2\" ], \"ops\" : [ \"ops1\" ], \"labels\" : { \"department\" : \"departmentA\", \"main_class\" : \"mainClassA\" }} 概念解析 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 primary key primary key 主键,MongoDB自动将_id字段设置为主键 在MySql 中 id name birthday sex 1 张豆豆 19960601 男 2 杨花花 19950726 女 在mongoDBzhong 中123456789101112{ \"_id\": ObjectId(\"5c89f787ca6e4e3ac1ehhb23\"), \"name\": \"张豆豆\", \"birthday\": \"19960601\", \"sex\": \"男\"},{ \"_id\" : ObjectId(\"5c89f787ca6e4e3ac1ehhb24\"), \"name\": \"杨花花\", \"birthday\": \"19950726\", \"sex\": \"女\"}, 应用场景适用的场景 无需要跨文档或跨表的事务及复杂的join查询支持 // 目前已经支持事务，join的支持也越来越好。 敏捷迭代的业务，需求变动频繁，数据模型无法确定 存储的数据格式灵活，不固定，或属于半结构化数据 业务并发访问量大，需数千的QPS(每秒查询率) TB级以上的海量数据存储，且数据量不断增加 要求存储的数据持久化、不丢失 需要99.999%的数据高可用性 场景举例： 游戏场景：使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新 物流场景：使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。 社交场景：使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能 物联网场景：使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析 视频直播：使用 MongoDB 存储用户信息、礼物信息等 …… 案例1 用在应用服务器的日志记录，查找起来比文本灵活，导出也很方便。也是给应用练手，从外围系统开始使用MongoDB。用在一些第三方信息的获取或者抓取，因为MongoDB的schema-less，所有格式灵活，不用为了各种格式不一样的信息专门设计统一的格式，极大的减少开发的工作。 案例2 mongodb之前有用过，主要用来存储一些监控数据，No schema 对开发人员来说，真的很方便，增加字段不用改表结构，而且学习成本极低。 案例3 使用MongoDB做了O2O快递应用，·将送快递骑手、快递商家的信息（包含位置信息）存储在 MongoDB，然后通过 MongoDB 的地理位置查询，这样很方便的实现了查找附近的商家、骑手等功能，使得快递骑手能就近接单，目前在使用MongoDB 上没遇到啥大的问题，官网的文档比较详细，很给力。 不适用的场景： 要求高度事务性的系统。 复杂的跨表级联查询。 安装Homebrew安装1brew tap mongodb/brew 1brew install mongodb-community@4.2 环境变量：打开 .bash_profile 1open -e .bash_profile 添加一行 1export PATH=/usr/local/Cellar/mongodb-community/4.2.1/bin:${PATH}} 然后 1source .bash_profile 开机自启： 1ln -sfv /usr/local/Cellar/mongodb-community/4.2.1/*.plist ~/Library/LaunchAgents 手动安装 下载 下载地址： https://www.mongodb.com/download-center/community?jmp=nav 选择版本及对应的操作系统后进行下载 将下载完成的文件解压并重命名为mongodb 将文件夹移动到 /usr/local 目录下 配置环境变量在命令行中输入 12345open -e .bash_profile``` 在打开的文件中添加一行``` bashexport PATH=${PATH}:/usr/local/mongodb/bin 在命令行中输入 1source .bash_profile 创建mongodb数据存储目录1mkdir -p /data/db 启动启动服务 1mongod 然后打开另一个命令行窗口，输入 1mongo 这样就可以操作mongodb了。 与PHP一起使用 在PHP中使用MongoDB，需要安装PHP-MongoDB驱动我使用pecl安装 1pecl install mongodb 1. 直接使用12345678910111213141516171819202122$manager = new MongoDB\\Driver\\Manager(\"mongodb://localhost:27017\"); // 插入数据$bulk = new MongoDB\\Driver\\BulkWrite;$bulk-&gt;insert(['x' =&gt; 1, 'name'=&gt;'baidu', 'url' =&gt; 'http://www.baidu.com']);$bulk-&gt;insert(['x' =&gt; 2, 'name'=&gt;'Google', 'url' =&gt; 'http://www.google.com']);$bulk-&gt;insert(['x' =&gt; 3, 'name'=&gt;'taobao', 'url' =&gt; 'http://www.taobao.com']);$manager-&gt;executeBulkWrite('test.sites', $bulk);$filter = ['x' =&gt; ['$gt' =&gt; 1]];$options = [ 'projection' =&gt; ['_id' =&gt; 0], 'sort' =&gt; ['x' =&gt; -1],];// 查询数据$query = new MongoDB\\Driver\\Query($filter, $options);$cursor = $manager-&gt;executeQuery('test.sites', $query);foreach ($cursor as $document) { print_r($document);} 2. 使用官方扩展包安装1composer require mongodb/mongodb 使用12345678910//连接$client = new MongoDB\\Client('mongodb://localhost:27017');//选择数据库$db = $client-&gt;selectDatabase(\"db\");//选择文档$collection = $db-&gt;selectCollection(\"collection\");//查询$result = $collection-&gt;findOne(['name' =&gt; 'panda']);//... 3. 在Yii中使用 我平时用Yii比较多，所以记录一下在Yii中的使用方法。 安装1composer require yiisoft/yii2-mongodb 配置在配置文件的 components 中加入 12345678'mongodb' =&gt; [ 'class' =&gt; '\\yii\\mongodb\\Connection', 'dsn' =&gt; 'mongodb://localhost:27017/dbName', 'options' =&gt; [ \"username\" =&gt; \"Username\", \"password\" =&gt; \"Password\" ]]; 使用 组件使用 12345$collection = Yii::$app-&gt;mongodb-&gt;getCollection ( 'user' );$res = $collection-&gt;insert ( [ 'name' =&gt; 'Panda', 'ag3' =&gt; 18] ); model中使用与MySQL类似，创建一个model文件，继承 yii\\mongodb\\ActiveRecord 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?phpnamespace frontend\\models;use Yii;use yii\\db\\ActiveRecord;/** * This is the model class for table \"vote_log\". * * @property int $id * @property int $user_id * @property int $post_id * @property string $post_type * @property int $created_at * @property int $updated_at * @property int $if_deleted */class VoteLog extends yii\\mongodb\\ActiveRecord{ /** * 定义集合名称 注意是 collectionName，不是 tableName * {@inheritdoc} */ public static function collectionName() { return 'vote_log'; } /** * 定义规则 * {@inheritdoc} */ public function rules() { return [ [['user_id', 'post_id'], 'required'], [['user_id', 'post_id', 'created_at', 'updated_at', 'if_deleted'], 'integer'], [['user_id', 'post_id',], 'integer'], [['post_type'], 'string', 'max' =&gt; 20], ]; } /** * 定义字段 注意是 attributes，不是 attributeLabels * {@inheritdoc} */ public function attributes() { return [ '_id', //_id一定要有 'id', 'user_id', 'post_id', 'post_type', 'created_at', 'updated_at', 'if_deleted', ]; } /** * 查找点赞记录 * @param $postId * @param $userId * @param int $ifDeleted */ public static function findVoteLog($postId, $userId) { $voted = self::findOne(['post_id' =&gt; $postId, 'user_id' =&gt; $userId]); return $voted; }}","link":"/2019/12/06/mongodb-learning/"},{"title":"Shell脚本学习笔记","text":"这是用来记录学习shell的文章。 本文所写内容主要是根据网络教程和自我理解所得，如有错误之处，请指出。 解释器一般shell脚本的第一行都是以 #!/bin/sh 开头，#! 标识用什么解释器来执行此脚本。 解释器的种类很多，比较常见的就是： /bin/sh /bin/bash 注释在一行开头使用# 12# author: 你的小可爱# date: 2019-07-14 shell中没有多行注释 变量命名规则 只能使用字母、数字、下划线，不能以数字开头 不能使用特殊符号 不能使用关键字 变量名示例： 12345idUSERNAMEfavoritefavorite2_sex 使用变量定义变量1name=\"你的小可爱\" 注意点： 定义变量时，变量名不需要使用$符号 等号前后不能有空格 使用变量123456echo $nameecho ${name}echo \"我的名字是：${name}\"name=\"大家的小可爱\"echo $name 注意点： 定义变量时变量名前不需要加$，但使用时需要加$。 重新定义变量时，变量名前不需要加$,只在使用变量时才加。 字符串单双引号在shell中字符串可以使用单引号、双引号，也可以不使用。 123str='Hello World.'str2=\"你好世界\"str3=泥豪啊 注意点： 单引号中的内容会原样输出，单引号中的变量无效 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行） 双引号中可以使用变量和转义字符 123age=18;echo 'my age is ${age}'echo \"my age is ${age} \\nHow old are you?\" 输出： 123my age is ${age}my age is 18How old are you? 字符串操作字符串拼接1234567891011name=\"你的小可爱\"echo \"你好，我是${name}\"echo \"你好，我是\"$nameecho \"你好，我是\"$name\"，哈哈\"echo '你好，我是'$name'，哈哈'# 输出# 你好，我是你的小可爱# 你好，我是你的小可爱# 你好，我是你的小可爱，哈哈# 你好，我是你的小可爱，哈哈 字符串长度123str=\"hello\";echo ${#str};#输出：5 字符串截取123456str=\"abcdefg\"echo ${str:1:3} # 输出 bcdecho ${str:0:4}# 输出 abcd 用户输入执行脚本时传入 在执行脚本时可向脚本传入参数，参数之间用空格隔开，在脚本内使用$n来接收参数，n代表是第几个参数，如$1代表第一个参数。 如果参数内有空格，可以使用引号将参数括起来。 1234echo \"执行的文件名：$0\"echo \"第一个参数为：$1\"echo \"第二个参数为：$2\"echo \"第二个参数为：$3\" 1234➜ ./test.sh 1 &apos;2 22&apos; &quot;3 33&quot;第一个参数为：1第二个参数为：2 22第二个参数为：3 33 获取传入参数的个数，使用$# 12echo \"传入参数个数：\"$#echo \"传入参数个数：${#}\" 123➜ ./test.sh 1 &apos;2 22&apos; &quot;3 33&quot;传入参数个数：3传入参数个数：3 运行脚本时输入使用read在程序运行时获取用户输入的参数 123echo \"Please enter your name:\"read nameecho \"Hello $name\" 1234➜ ./test.shPlease enter your name:熊小帅Hello 熊小帅 使用-p直接指定一个提示语句 12read -p \"Please enter your name:\" nameecho \"Hello $name\" 123➜ ./test.shPlease enter your name:熊大帅Hello 熊大帅 使用-t进行倒计时，用户需要在指定时间(秒)内完成输入 12345678if read -t 5 -p \"Please enter your name in 5 seconds:\" namethen echo \"Hello $name\"else echo echo \"timeout\"fi 123➜ ./test.shPlease enter your name in 5 seconds:timeout 使用-s隐藏输入内容 123read -s -p \"Please enter your password:\" pwdechoecho \"I got it! Your password is: $pwd\" 123➜ ./test.shPlease enter your password:I got it! Your password is: 123456 运算符shell中的运算符包括： 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 在Linux的shell中，变量的值的类型默认是字符串，不能直接进行数值运算。但是可以通过其他命令来实现，如expr。 12echo `expr 1 + 2`# 输出：3 注意： 表达式需要用反引号``括起来 表达式和运算符之间要用空格隔开，如1 + 2不能写成1+2，= 赋值时，前后无空格 算数运算符 运算符 说明 + 加 - 减 * 乘 / 除 % 取余 = 赋值 == 相等 != 不等 1234567891011121314151617#!/bin/basha=1b=2echo `expr $a + $b`echo `expr $a - $b`echo `expr $a \\* $b`echo `expr $b / $a`echo `expr $b % $a`if [ $a == $b ]then echo \"a等于b\"fiif [ $a != $b ]then echo \"a不等于b\"fi 1234563-1220a不等于b 注意： []代表一个表达式，[]中的内容要与两侧的符号使用空格隔开，如[ $a + $b ]，不能写成[$a+$b] 乘号*前边必须加反斜杠\\ 在MAC上，expr语法可以写成 $((表达式))，亲测表达式和运算符之间可以不加空格，$(($a+$b))和$(($a + $b))都可以；乘法写成$(($a*$b))，不需要加\\ MAC shell 1234567891011121314151617#!/bin/basha=1b=2echo $(($a + $b))echo $(($a-$b))echo $(($a*$b))echo $(($b/$a))echo $(($b%$a))if [ $a == $b ]then echo \"a等于b\"fiif [ $a != $b ]then echo \"a不等于b\"fi 1234563-1220a不等于b 关系运算符 运算符 说明 -eq 相等 -ne 不等 -gt 大于 -lt 小于 -ge 大于等于 -le 小于等于 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/basha=1b=2if [ $a -eq $b ]then echo \"a等于b\"else echo \"a不等于b\"fiif [ $a -ne $b ]then echo \"a不等于b\"else echo \"a等于b\"fiif [ $a -gt $b ]then echo \"a大于b\"else echo \"a不大于b\"fiif [ $a -lt $b ]then echo \"a小于b\"else echo \"a不小于b\"fiif [ $a -ge $b ]then echo \"a大于等于b\"else echo \"a小于b\"fiif [ $a -le $b ]then echo \"a小于等于b\"else echo \"a大于b\"fi 输出 1234567➜ sh test.sha不等于ba不等于ba不大于ba小于ba小于ba小于等于b 布尔运算符 运算符 说明 ! 非 -o 或 -a 与 12345678910111213141516171819202122232425#!/bin/basha=1b=20if [ $a != $b ]then echo \"a不等于b\"else echo \"a等于b\"fiif [ $a -gt 2 -o $b -gt 10 ]then echo \"a大于2或b大于10\"else echo \"a小于等于2并且b小于等于10\"fiif [ $a -gt 2 -a $b -gt 10 ]then echo \"a大于2并且b大于10\"else echo \"a小于等于2或者b小于等于10\"fi 输出： 1234➜ sh test.sha不等于ba大于2或b大于10a小于等于2或者b小于等于10 逻辑运算符 运算符 说明 &amp;&amp; 逻辑and || 逻辑or 123456789101112131415161718#!/bin/basha=1b=20if [[ $a -lt 2 &amp;&amp; $b -gt 10 ]]then echo \"a小于2并且b大于10\"else echo \"a大于等于2或者b小于等于10\"fiif [[ $a -lt 2 || $b -gt 10 ]]then echo \"a小于2或者b大于10\"else echo \"a大于等于2并且b小于等于10\"fi 输出： 123➜ sh test.sha小于2并且b大于10a小于2或者b大于10 [[ ]] 是什么？ 字符串运算符 运算符 说明 = 检测两个字符串是否相等 != 检测两个字符串是否相等 -z 检测字符串长度是否为0 -n 检测字符串长度是否不为0 $ 检测字符串是否不为空 123456789101112131415161718192021222324252627282930313233343536373839#!/bin/basha=\"abc\"b=\"def\"if [ $a = $b ]then echo \"a等于b\"else echo \"a不等于b\"fiif [ $a != $b]then echo \"a不等于b\"else echo \"a等于b\"fiif [ -z $a ]then echo \"a的长度为0\"else echo \"a的长度不为0\"fiif [ -n $a ]then echo \"a的长度不为0\"else echo \"a的长度为0\"fiif [ $a ]then echo \"a不为空\"else echo \"a为空\"fi 输出： 123456➜ sh test.sha不等于ba不等于ba的长度不为0a的长度不为0a不为空 文件测试运算符 运算符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bashfile=\"/var/www/runoob/test.sh\"if [ -r $file ]then echo \"文件可读\"else echo \"文件不可读\"fiif [ -w $file ]then echo \"文件可写\"else echo \"文件不可写\"fiif [ -x $file ]then echo \"文件可执行\"else echo \"文件不可执行\"fiif [ -f $file ]then echo \"文件为普通文件\"else echo \"文件为特殊文件\"fiif [ -d $file ]then echo \"文件是个目录\"else echo \"文件不是个目录\"fiif [ -s $file ]then echo \"文件不为空\"else echo \"文件为空\"fiif [ -e $file ]then echo \"文件存在\"else echo \"文件不存在\"fi 输出： 1234567文件可读文件可写文件可执行文件为普通文件文件不是个目录文件不为空文件存在 数组与大多数编程语言一样，数组下标从0开始，且Bash Shell只支持一维数组。Shell 数组用括号来表示，元素用空格分开. 定义数组1array=(A B C \"D\") 也可使使用下标来定义数组 1234array[0]=Aarray[1]=Barray[2]=Carray[3]=\"D\" 读取数组读取数组的格式为： ${array[index]} 1234567#!/bin/basharray=(A B C \"D\")echo \"第一个元素：${array[0]}\"echo \"第二个元素：${array[1]}\"echo \"第三个元素：${array[2]}\"echo \"第四个元素：${array[3]}\" 输出： 12345➜ sh test.sh第一个元素：A第二个元素：B第三个元素：C第四个元素：D 获取数组中的所有元素使用@或者*来获取数组中的所有元素 12345#!/bin/basharray=(A B C D)echo \"数组中的所有元素${array[*]}\"echo \"数组中的所有元素${array[@]}\" 输出： 123➜ sh test.sh数组中的所有元素A B C D数组中的所有元素A B C D 获取数组的长度获取数组长度的方法与字符串类似。 12345#!/bin/basharray=(A B C D)echo \"数组元素个数${#array[*]}\"echo \"数组元素个数${#array[@]}\" 输出： 123➜ sh test.sh数组元素个数4数组元素个数4 流程控制if格式 1234if 条件then 执行语句fi if else123456if 条件then 执行语句else 执行语句2fi if else-if else123456789if 条件then 执行语句elif 条件2then 执行语句2else 执行语句3fi for格式： 1234for item in itemsdo 执行命令done 例子： 123456#!/bin/bashfor item in 1 2 3 4do echo $itemdone 1234567#!/bin/basharr=(1 2 3 4)for item in ${arr[*]}do echo $itemdone 以上两个都会输出： 12341234 while格式： 1234while 条件do 执行命令done 例子： 12345678#!/bin/basha=1while [ $a -lt 5 ]do echo $a a=`expr $a + 1`done 输出： 12345➜ sh test.sh1234 while循环可用于读取键盘信息：只有当用户按下 ctrl+D 时程序才会退出 1234567#!/bin/bashecho \"请输入你的名字： （按 ctrl+d 退出）\"while read inputdo echo \"hello ${input}\"done 输出： 123456➜ sh test.sh请输入你的名字： （按 ctrl+d 退出）吴彦祖hello 吴彦祖古天乐hello 古天乐 untiluntil与while相反，当条件成立时退出格式： 1234until 条件do 执行命令done 例子： 12345678#!/bin/basha=0until [ $a -gt 10 ] do echo $a a=`expr $a + 1`done 输出： 123456789101112➜ sh test.sh012345678910 case格式： 1234567891011case 值 in值1) 命令1 ;;值2) 命令2 ;;*) 其他值 ;;esac 例子： 1234567891011121314151617#!/bin/bashread -p \"请输入1-3之间的数字：\" numcase $num in 1) echo \"你输入的是1\" ;; 2) echo \"你输入的是2\" ;; 3) echo \"你输入的是3\" ;; *) echo \"你没有输入1-3之间的数字\" ;;esac 输出： 123➜ sh test.sh请输入1-3之间的数字：1你输入的是1 跳出循环与PHP语法类似continue 跳过本次循环break 跳出所有循环 函数函数定义格式： 1234567#!/bin/bashtestFun(){ echo \"11111\";}testFun 输出： 111111 所有函数在使用前必须定义 函数返回值123456789101112#!/bin/bashreadFun(){ echo \"演示两个数字相加\" read -p \"请输入第一个数字：\" first read -p \"请输入第二个数字：\" second return `expr $first + $second`}readFunecho \"两数之和为$?\" 输出： 12345➜ sh test.sh演示两个数字相加请输入第一个数字：1请输入第二个数字：2两数之和为3 函数返回值在调用该函数后通过 $? 来获得 函数参数1234567891011#!/bin/bashparamFun(){ echo \"第一个参数：${1}\" echo \"第二个参数：$2\" echo \"第三个参数：$3\" echo \"一共有${#}个参数\" echo \"输出所有参数：$@\"}paramFun 1 2 3 4 输出： 123456➜ sh test.sh第一个参数：1第二个参数：2第三个参数：3一共有4个参数输出所有参数：1 2 3 4 与执行脚本时传入参数类似，调用函数时传入参数用空格隔开，在函数内部通过$n的形式来获取传入参数 需要注意的是，当获取第n&gt;=10个参数时，需要通过${n}的形式来获取，当然小于10的时候也是能通过${n}的形式来获取参数 printf默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \\n。 12echo \"hello\"printf \"hello\\n\" 与其他编程语言类似 1234#!/bin/bashprintf \"你好，我今年%s岁\" 18printf \"我的名字叫：%-3s\" 熊小帅printf \"我的体重是：%-4.2fkg\" 70.5 输出： 1234➜ sh test.sh你好，我今年18岁我的名字叫：熊小帅我的体重是：70.50kg %-3s -表示左对齐，3 表示显示3个字符，%-4.2f .2表示保留两位小数","link":"/2019/07/14/shell-script-leaning/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","link":"/tags/Homebrew/"},{"name":"LNMP","slug":"LNMP","link":"/tags/LNMP/"},{"name":"openSSL","slug":"openSSL","link":"/tags/openSSL/"},{"name":"RSA","slug":"RSA","link":"/tags/RSA/"},{"name":"并发","slug":"并发","link":"/tags/并发/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Safari","slug":"Safari","link":"/tags/Safari/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"}],"categories":[{"name":"Skills","slug":"Skills","link":"/categories/Skills/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"MongoDB","slug":"MongoDB","link":"/categories/MongoDB/"},{"name":"Shell","slug":"Shell","link":"/categories/Shell/"}]}