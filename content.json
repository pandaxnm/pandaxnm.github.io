{"meta":{"title":"小熊Blog","subtitle":"折腾不止","description":null,"author":"chaojie.xiong","url":"https://mokeee.com"},"pages":[{"title":"关于我","date":"2019-06-09T10:21:46.000Z","updated":"2019-07-15T13:03:03.514Z","comments":true,"path":"about/index.html","permalink":"https://mokeee.com/about/index.html","excerpt":"","text":"因为很菜，所以不断学习中…"}],"posts":[{"title":"Shell脚本学习笔记","slug":"shell-script-leaning","date":"2019-07-14T07:23:20.000Z","updated":"2019-07-15T14:28:34.834Z","comments":true,"path":"2019/07/14/shell-script-leaning/","link":"","permalink":"https://mokeee.com/2019/07/14/shell-script-leaning/","excerpt":"这是用来记录学习shell的文章，不断更新中。","text":"这是用来记录学习shell的文章，不断更新中。 本文所写内容主要是根据网络教程和自我理解所得，如有错误之处，请指出。 解释器一般shell脚本的第一行都是以 !#/bin/sh 开头，!# 标识用什么解释器来执行此脚本。 解释器的种类很多，比较常见的就是： /bin/sh /bin/bash 注释在一行开头使用# 12# author: 你的小可爱# date: 2019-07-14 shell中没有多行注释 变量命名规则 只能使用字母、数字、下划线，不能以数字开头 不能使用特殊符号 不能使用关键字 变量名示例： 12345idUSERNAMEfavoritefavorite2_sex 使用变量定义变量1name=\"你的小可爱\" 注意点： 定义变量时，变量名不需要使用$符号 等号前后不能有空格 使用变量123456echo $nameecho $&#123;name&#125;echo \"我的名字是：$&#123;name&#125;\"name=\"大家的小可爱\"echo $name 注意点： 定义变量时变量名前不需要加$，但使用时需要加$。 重新定义变量时，变量名前不需要加$,只在使用变量时才加。 字符串单双引号在shell中字符串可以使用单引号、双引号，也可以不使用。 123str='Hello World.'str2=\"你好世界\"str3=泥豪啊 注意点： 单引号中的内容会原样输出，单引号中的变量无效 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行） 双引号中可以使用变量和转义字符 123age=18;echo 'my age is $&#123;age&#125;'echo \"my age is $&#123;age&#125; \\nHow old are you?\" 输出： 123my age is $&#123;age&#125;my age is 18How old are you? 字符串操作字符串拼接1234567891011name=\"你的小可爱\"echo \"你好，我是$&#123;name&#125;\"echo \"你好，我是\"$nameecho \"你好，我是\"$name\"，哈哈\"echo '你好，我是'$name'，哈哈'# 输出# 你好，我是你的小可爱# 你好，我是你的小可爱# 你好，我是你的小可爱，哈哈# 你好，我是你的小可爱，哈哈 字符串长度123str=\"hello\";echo $&#123;#str&#125;;#输出：5 字符串截取123456str=\"abcdefg\"echo $&#123;str:1:3&#125; # 输出 bcdecho $&#123;str:0:4&#125;# 输出 abcd 用户输入执行脚本时传入 在执行脚本时可向脚本传入参数，参数之间用空格隔开，在脚本内使用$n来接收参数，n代表是第几个参数，如$1代表第一个参数。 如果参数内有空格，可以使用引号将参数括起来。 1234echo \"执行的文件名：$0\"echo \"第一个参数为：$1\"echo \"第二个参数为：$2\"echo \"第二个参数为：$3\" 1234➜ ./test.sh 1 &apos;2 22&apos; &quot;3 33&quot;第一个参数为：1第二个参数为：2 22第二个参数为：3 33 获取传入参数的个数，使用$# 12echo \"传入参数个数：\"$#echo \"传入参数个数：$&#123;#&#125;\" 123➜ ./test.sh 1 &apos;2 22&apos; &quot;3 33&quot;传入参数个数：3传入参数个数：3 运行脚本时输入使用read在程序运行时获取用户输入的参数 123echo \"Please enter your name:\"read nameecho \"Hello $name\" 1234➜ ./test.shPlease enter your name:熊小帅Hello 熊小帅 使用-p直接指定一个提示语句 12read -p \"Please enter your name:\" nameecho \"Hello $name\" 123➜ ./test.shPlease enter your name:熊大帅Hello 熊大帅 使用-t进行倒计时，用户需要在指定时间(秒)内完成输入 12345678if read -t 5 -p \"Please enter your name in 5 seconds:\" namethen echo \"Hello $name\"else echo echo \"timeout\"fi 123➜ ./test.shPlease enter your name in 5 seconds:timeout 使用-s隐藏输入内容 123read -s -p \"Please enter your password:\" pwdechoecho \"I got it! Your password is: $pwd\" 123➜ ./test.shPlease enter your password:I got it! Your password is: 123456 运算符shell中的运算符包括： 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 在Linux的shell中，变量的值的类型默认是字符串，不能直接进行数值运算。但是可以通过其他命令来实现，如expr。 12echo `expr 1 + 2`# 输出：3 注意： 表达式需要用反引号``括起来 表达式和运算符之间要用空格隔开，如1 + 2不能写成1+2，= 赋值时，前后无空格 算数运算符 运算符 说明 + 加 - 减 * 乘 / 除 % 取余 = 赋值 == 相等 != 不等 1234567891011121314151617#!/bin/basha=1b=2echo `expr $a + $b`echo `expr $a - $b`echo `expr $a \\* $b`echo `expr $b / $a`echo `expr $b % $a`if [ $a == $b ]then echo \"a等于b\"fiif [ $a != $b ]then echo \"a不等于b\"fi 1234563-1220a不等于b 注意： []代表一个表达式，[]中的内容要与两侧的符号使用空格隔开，如[ $a + $b ]，不能写成[$a+$b] 乘号*前边必须加反斜杠\\ 在MAC上，expr语法可以写成 $((表达式))，亲测表达式和运算符之间可以不加空格，$(($a+$b))和$(($a + $b))都可以；乘法写成$(($a*$b))，不需要加\\ MAC shell 1234567891011121314151617#!/bin/basha=1b=2echo $(($a + $b))echo $(($a-$b))echo $(($a*$b))echo $(($b/$a))echo $(($b%$a))if [ $a == $b ]then echo \"a等于b\"fiif [ $a != $b ]then echo \"a不等于b\"fi 1234563-1220a不等于b","categories":[{"name":"Shell","slug":"Shell","permalink":"https://mokeee.com/categories/Shell/"}],"tags":[],"keywords":[{"name":"Shell","slug":"Shell","permalink":"https://mokeee.com/categories/Shell/"}]},{"title":"使用Redis锁来处理并发","slug":"redis-lock","date":"2019-07-10T15:05:49.000Z","updated":"2019-07-15T12:57:30.419Z","comments":true,"path":"2019/07/10/redis-lock/","link":"","permalink":"https://mokeee.com/2019/07/10/redis-lock/","excerpt":"","text":"问题： 最近在和第三方对接支付，今天看日志发现他们的回调竟然并发了，有点方。虽然每次回调的时候，都会查数据库检查这个订单的状态，然后对进行相应处理。但同一个订单如果遇到并发，第一个请求还没写入数据库，第二个请求就来了，这种情况就会导致错误。 解决办法： 使用Redis锁，每个请求到达时先加锁，如果加锁成功才会执行后面的业务逻辑，执行结束后释放锁。 比如：同一个订单并发的情况，我们可以使用订单号作为Redis的键名，每次请求前都会先加锁，如果加锁失败，说明该订单正在进行处理，并把这个请求挡回去；如果加锁成功，则执行后面的业务逻辑，并在完成后解锁。 我想到的是使用Redis的set命令，2.6.12之后版本，Redis set指令支持了nx、ex模式，并支持原子化地设置过期时间。 NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。 PHP实现 加锁12345678910111213141516171819/** * 加锁 * @param string $orderId 订单ID * @return bool|int 加锁成功返回唯一锁ID，加锁失败返回false */public static function addLock($orderId)&#123; if(!$orderId)&#123; return false; &#125; $key = self::REDIS_LOCK_NAME . $orderId; $client = BaseRedis::getClient(); //生成锁ID 自行实现 $lockId = uniqid(); //需要设置一个到期时间，避免死锁 $res = $client-&gt;set($key, $lockId, ['nx', 'ex' =&gt; self::REDIS_LOCK_EXPIRE_TIME]); return $res ? $lockId : $res;&#125; 2.解锁 解锁时用lockId进行比较，如果相等则删除锁。 watch: 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 1234567891011121314151617181920212223/** * 解锁 * @param string $orderId 订单ID * @param string $lockId 锁唯一ID * @return bool */public static function unLock($orderId, $lockId)&#123; if(!$orderId)&#123; return false; &#125; $key = self::REDIS_LOCK_NAME . $orderId; $client = BaseRedis::getClient(); $client-&gt;watch($key); if ($lockId == $client-&gt;get($key)) &#123; // 以 MULTI 开始一个事务，然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务，一并执行事务中的所有命令 $client-&gt;multi()-&gt;del($key)-&gt;exec(); return true; &#125; $client-&gt;unwatch(); return false;&#125; 目前对分布式缓存还不太了解，后续学习。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://mokeee.com/categories/Redis/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://mokeee.com/tags/并发/"},{"name":"Redis","slug":"Redis","permalink":"https://mokeee.com/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://mokeee.com/categories/Redis/"}]},{"title":"使用OpenSSL进行RSA签名和加密解密","slug":"open-ssl-rsa-sign-encrypt","date":"2019-07-09T03:56:32.000Z","updated":"2019-07-10T15:28:24.146Z","comments":true,"path":"2019/07/09/open-ssl-rsa-sign-encrypt/","link":"","permalink":"https://mokeee.com/2019/07/09/open-ssl-rsa-sign-encrypt/","excerpt":"PHP7之后，mcrypt扩展就已经被弃用，我们可以使用OpenSSL拓展来代替。","text":"PHP7之后，mcrypt扩展就已经被弃用，我们可以使用OpenSSL拓展来代替。 RSA加密算法是一种非对称加密算法，用法总结起来就是：公钥加密、私钥解密、私钥签名、公钥验签。 签名与加密的作用：1.签名是为了防止数据被篡改2.加密是为了防止数据被泄露 格式化公钥私钥1234567891011121314151617181920212223/** * 格式化私钥 * @param $privateKey * @return string */ private function getPrivateKey($privateKey) &#123; $key = chunk_split($privateKey,64,\"\\n\"); $key = \"-----BEGIN PRIVATE KEY-----\\n\" . $key . \"-----END PRIVATE KEY-----\\n\"; return $key; &#125; /** * 格式化公钥 * @param $privateKey * @return string */ private function getPublicKey($publicKey)&#123; $key = chunk_split($publicKey,64,\"\\n\"); $key = \"-----BEGIN PUBLIC KEY-----\\n\" . $key . \"-----END PUBLIC KEY-----\\n\"; return $key; &#125; 使用私钥签名12345678910111213/** * 签名 * @param $params * @param $privateKey * @return string */private function sign($data, $privateKey)&#123; $signature = ''; openssl_sign($str, $signature, $privateKey, OPENSSL_ALGO_SHA1); return base64_encode($signature);&#125; 使用公钥验签1234567891011121314151617/** * 验签 * @param $return * @param $sign * @param $publicKey * @return bool */public function verify($params, $sign, $publicKey)&#123; $verify = openssl_verify($params, base64_decode($sign), $publicKey); if ($verify != 1) &#123; return false; &#125; return true;&#125; 使用公钥加密1234567891011121314/** * rsa 公钥加密 * @param $data string 待加密的数据 * @param string $public_key 公钥 * @return string */public function rsaPublicEncrypt($data, $publicKey)&#123; $key = openssl_pkey_get_public($publicKey); $encrypted = ''; openssl_public_encrypt($data, $encrypted, $key); return base64_encode($encrypted);&#125; 使用私钥解密1234567891011/** * 私钥解密 * @param $encrypted 被加密的数据 * @param $private_key 私钥 * @return string */public function rsaPrivateDecrypt($encrypted, $private_key)&#123; openssl_private_decrypt(base64_decode($encrypted),$decrypted,$private_key); return $decrypted;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://mokeee.com/categories/PHP/"}],"tags":[{"name":"openSSL","slug":"openSSL","permalink":"https://mokeee.com/tags/openSSL/"},{"name":"RSA","slug":"RSA","permalink":"https://mokeee.com/tags/RSA/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://mokeee.com/categories/PHP/"}]},{"title":"Mac上使用Homebrew搭建LNMP环境（简要版）","slug":"mac-homebrew-lnmp","date":"2019-06-09T09:18:39.000Z","updated":"2019-06-09T14:19:23.084Z","comments":true,"path":"2019/06/09/mac-homebrew-lnmp/","link":"","permalink":"https://mokeee.com/2019/06/09/mac-homebrew-lnmp/","excerpt":"最近发现自己这台Mac充电口已经糊掉了，并且使用的时候发热严重，于是向公司申请了一台。","text":"最近发现自己这台Mac充电口已经糊掉了，并且使用的时候发热严重，于是向公司申请了一台。 结果给了我一台13寸的，而且键盘磨得漆都掉了。🤣 拿到手第一件事情就是咔咔重装系统，然后开始装开发环境。 一、安装Homebrew1.安装comman line Homebrew 是一个包管理器，用于在Mac上安装一些OS X没有的UNIX工具 1xcode-select --install 如果提示失败，请尝试手动安装到这个地址 https://developer.apple.com/download/more/ 下载Command Line Tools，选择适合自己的版本。 2.安装Homebrew运行下面的命令即可安装Homebrew，安装开始前会有提示，同意即可。 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 二、安装Nginx运行下面的命令来安装 1brew install nginx 安装完成后将Nginx加入开机自启 12cp /usr/local/opt/nginx/homebrew.mxcl.nginx.plist ~/Library/LaunchAgents/launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist 给Nginx root权限 (路径根据版本而定) 12sudo chown root:wheel /usr/local/Cellar/nginx/1.6.0_1/bin/nginxsudo chmod u+s /usr/local/Cellar/nginx/1.6.0_1/bin/nginx 如果nginx启动报错：nginx: [error] open() &quot;/usr/local/var/run/nginx.pid&quot; failed (2: No such file or directory) 执行 1sudo nginx -c /usr/local/etc/nginx/nginx.conf 三、安装MySql1brew install mysql@5.7 安装完成后开启mysql： 1/usr/local/opt/mysql@5.7/bin/mysql.server start 然后设置密码： 1/usr/local/opt/mysql@5.7/bin/mysql_secure_installation 根据提示操作即可 将MySql加入开机自启（路径根据版本而定） 12cp /usr/local/opt/mysql@5.7/homebrew.mxcl.mysql@5.7.plist ~/Library/LaunchAgents/launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql@5.7.plist 四、安装PHP1.安装PHP1brew install php@7.1 将php加入环境变量，运行： 12echo 'export PATH=\"/usr/local/opt/php@7.1/bin:$PATH\"' &gt;&gt; ~/.bash_profileecho 'export PATH=\"/usr/local/opt/php@7.1/sbin:$PATH\"' &gt;&gt; ~/.bash_profile 关闭终端，重新打开 2.安装PHP扩展我们可以使用pecl命令来安装PHP拓展，如果你安装的PHP版本&gt;=7.1，pecl也一同安装好了。 使用pecl安装拓展，只需执行命令即可，其他的会给你自动配置好，是不是敲方便的！ 安装Yaf扩展：pecl install yaf安装redis扩展： pecl install install安装debug：pecl install xdebug 扩展安装完成后记得重启php-fpm 1brew services restart php@7.1 五、安装redis同理，运行 1brew install redis 六、命令可能会用到的一些命令： 1. 搜索1brew search php 2.安装卸载1brew install\\uninstall php@7.1 3.启动\\重启\\停止服务：1brew services start\\restart\\stop nginx\\mysql@5.7\\php@7.1 4.查看某个包的信息：1brew info nginx 该命令会显示安装路径、配置文件等信息","categories":[],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"https://mokeee.com/tags/Homebrew/"},{"name":"LNMP","slug":"LNMP","permalink":"https://mokeee.com/tags/LNMP/"}],"keywords":[]},{"title":"记一次使用PHP将word转为excel的经历","slug":"word-to-excel-use-php","date":"2019-01-12T08:24:06.000Z","updated":"2019-06-09T09:18:02.850Z","comments":true,"path":"2019/01/12/word-to-excel-use-php/","link":"","permalink":"https://mokeee.com/2019/01/12/word-to-excel-use-php/","excerpt":"昨天一位朋友找到我，说他手上有几千个word表格需要转换到一个excel文件里，他在网上也没有找到满足需求的软件，于是让我帮忙用程序实现。","text":"昨天一位朋友找到我，说他手上有几千个word表格需要转换到一个excel文件里，他在网上也没有找到满足需求的软件，于是让我帮忙用程序实现。 需求需求如下图所示：每个文档文档中有一个或多个格式固定的表格，需要把每一个word表格转换为excel文件里的一行。 from: to: 寻找解决方案我首先想到的是用PHP读取word文档，处理之后转成excel。 转成excel比较简单，使用PHP系统函数fputcsv就可以搞定，现在需要做的是读取到word文档里的内容。 紧接着我便去网上查找，看有没有PHP的扩展能够读取word文档。在Github搜索到一个叫做 PHPWord 的扩展，不过遗憾的是，这个扩展只能往word文档里写入内容，并不能读取。 我又想，能不能把word转成其他格式再读取。于是我将word文档的后缀改成了txt,打开文件后内容如下图。 密密麻麻的一大堆，反正我是没能从中找到什么规律，于是放弃了这种方法。 接着我在word的另存为功能中，发现可以另存为其他格式。 于是选择保存为htm文件，随后在浏览器中打开转换好的文件，发现表格转换成了html中的table表格，非常标准。 这样我只需要遍历读取htm文件，获取其中的内容，再进行相应处理便能得到最终数据。 进行处理准备 首先我在网上下载了软件，将word文档批量转换为htm文件，并放在同一目录下 读取文件内容我们事先将所有转换好的文件放在了同一目录下，所以只需要遍历该目录，并使用file_get_contents()函数就能获取到每个文件的内容。 提取有用内容查看htm源代码能发现，每个word表格转换后变成了一个html表格，只需要先取到&lt;table&gt;&lt;/table&gt;标签里的内容，然后再按行分割，按列分割，便能得到我们想要的数据了。 附上简略代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//生成csv文件function writeExcel()&#123; //写入文档头部 $fileName = './data.csv'; file_put_contents($fileName,''); $handle = fopen($fileName, 'w'); fwrite($handle, chr(0xEF).chr(0xBB).chr(0xBF)); // 写入BOM头，防止乱码 $titleArr = ['A' =&gt; '样品类型', 'B' =&gt; '图幅编号'];//次数省略 fputcsv($handle, $titleArr); return $handle;&#125;//读取文件夹下的所有文件function scanFile($path)&#123; $result = []; $files = scandir($path); foreach ($files as $file) &#123; if ($file != '.' &amp;&amp; $file != '..') &#123; $result[] = basename($file); &#125; &#125; return $result;&#125;//提取表格内容function getContents()&#123; $filesArr = scanFile('./'); $handle = writeExcelHeader(); foreach ($filesName as $k =&gt; $v)&#123; //读取文件内容 $text = file_get_contents($path . $v); //转换编码 $text = iconv(\"gb2312\", \"utf-8//IGNORE\",$text); //去除html标签多余属性 $text = preg_replace(\"/&lt;([a-zA-Z]+)[^&gt;]*&gt;/\",\"&lt;\\\\1&gt;\",$text); //提取表格内容 preg_match_all(\"/&lt;table&gt;(.*?)&lt;\\/table&gt;/is\",$text,$matches); //处理表格内容 foreach ($matches[1] as $match)&#123; html2excel($match, $handle); &#125;&#125;//处理表格内容function convert($content)&#123; $res = []; //按行拆分 $trArr = explode('&lt;tr&gt;', $content); foreach ($trArr as $k =&gt; $tr)&#123; //去除多余标签 $tr = str_replace('&lt;/tr&gt;','', $tr); //按列拆分 $tdArr = explode('&lt;td&gt;', $tr); foreach ($tdArr as $kk =&gt; $td)&#123; //去除多余标签 $td = str_replace('&lt;/td&gt;','', $td); //去除html标签 得到内容 $text = strip_tags($td); $res[] = $text; &#125; &#125; fputcsv($handel, $res);&#125;getContents(); 最后使用到的一些函数： iconv() 编码转换 preg_replace() 使用正则替换文本 preg_match_all() 使用正则获取内容 strip_tags() 去除文本中的html标签 str_replace() 文本替换 fputcsv() 将制定内容写入csv文件","categories":[{"name":"PHP","slug":"PHP","permalink":"https://mokeee.com/categories/PHP/"}],"tags":[{"name":"Safari","slug":"Safari","permalink":"https://mokeee.com/tags/Safari/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://mokeee.com/categories/PHP/"}]},{"title":"Safari【阻止跨网站追踪】遇到的问题","slug":"safari-cookie","date":"2019-01-06T07:30:59.000Z","updated":"2019-06-09T09:17:04.172Z","comments":true,"path":"2019/01/06/safari-cookie/","link":"","permalink":"https://mokeee.com/2019/01/06/safari-cookie/","excerpt":"","text":"需求描述现有AB两个域名，分别使用在AB网站上。 A向B发送一个jsonp跨域请求，进行用户登录操作 B收到请求并验证通过后会在自己的域名下写一个包含当前用户信息的cookie 当A网站再次向B网站发起获取用户信息的请求时，B网站会读取自己域名下的这个cookie来获取当前用户的信息并返回给A 遇到的问题在Windows PC上测试时一切正常，没有任何问题。当使用Safari浏览器访问A网站时，用户登录操作正常，但在登录成功后，向B网站发起获取用户信息的请求时，总是提示获取不到。 在一番查找资料后发现，iOS系统上的Safari设置中默认开启了 阻止跨网站追踪 的功能，从而导致A网站向B网站发请求，B网站写cookie在B域名下的操作也无法完成… **这个问题会出现在所有使用AppleWebkit内核的浏览器中。 由于iOS系统限制，苹果只允许第三方浏览器使用AppleWebkit内核，所以按理iOS上的所有浏览器都会出现这个问题。 解决办法严格来说也不算解决办法，算曲线救国吧… 当A向B发起登录请求并收到返回的数据后，A网站前端将B返回的数据存在A的cookie中，并在以后每次请求B时将cookie中的信息以参数形式发送给B。","categories":[],"tags":[],"keywords":[]}]}